(self.webpackChunk_plone_volto=self.webpackChunk_plone_volto||[]).push([[9328],{"../../../node_modules/.pnpm/jotai@2.11.3_@types+react@18.3.20_react@18.2.0/node_modules/jotai/esm/react.mjs":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.d(__webpack_exports__,{lZ:function(){return useAtom}});var react__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("../../../node_modules/.pnpm/react@18.2.0/node_modules/react/index.js"),jotai_vanilla__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("../../../node_modules/.pnpm/jotai@2.11.3_@types+react@18.3.20_react@18.2.0/node_modules/jotai/esm/vanilla.mjs");const StoreContext=(0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(void 0),useStore=options=>{const store=(0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(StoreContext);return(null==options?void 0:options.store)||store||(0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_1__.K0)()},isPromiseLike=x=>"function"==typeof(null==x?void 0:x.then),attachPromiseMeta=promise=>{promise.status="pending",promise.then((v=>{promise.status="fulfilled",promise.value=v}),(e=>{promise.status="rejected",promise.reason=e}))},use=react__WEBPACK_IMPORTED_MODULE_0__.use||(promise=>{if("pending"===promise.status)throw promise;if("fulfilled"===promise.status)return promise.value;throw"rejected"===promise.status?promise.reason:(attachPromiseMeta(promise),promise)}),continuablePromiseMap=new WeakMap,createContinuablePromise=promise=>{let continuablePromise=continuablePromiseMap.get(promise);return continuablePromise||(continuablePromise=new Promise(((resolve,reject)=>{let curr=promise;const onFulfilled=me=>v=>{curr===me&&resolve(v)},onRejected=me=>e=>{curr===me&&reject(e)},registerCancelHandler=p=>{"onCancel"in p&&"function"==typeof p.onCancel&&p.onCancel((nextValue=>{if(nextValue===p)throw new Error("[Bug] p is not updated even after cancelation");isPromiseLike(nextValue)?(continuablePromiseMap.set(nextValue,continuablePromise),curr=nextValue,nextValue.then(onFulfilled(nextValue),onRejected(nextValue)),registerCancelHandler(nextValue)):resolve(nextValue)}))};promise.then(onFulfilled(promise),onRejected(promise)),registerCancelHandler(promise)})),continuablePromiseMap.set(promise,continuablePromise)),continuablePromise};function useAtomValue(atom,options){const store=useStore(options),[[valueFromReducer,storeFromReducer,atomFromReducer],rerender]=(0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)((prev=>{const nextValue=store.get(atom);return Object.is(prev[0],nextValue)&&prev[1]===store&&prev[2]===atom?prev:[nextValue,store,atom]}),void 0,(()=>[store.get(atom),store,atom]));let value=valueFromReducer;storeFromReducer===store&&atomFromReducer===atom||(rerender(),value=store.get(atom));const delay=null==options?void 0:options.delay;if((0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)((()=>{const unsub=store.sub(atom,(()=>{if("number"==typeof delay){const value2=store.get(atom);return isPromiseLike(value2)&&attachPromiseMeta(createContinuablePromise(value2)),void setTimeout(rerender,delay)}rerender()}));return rerender(),unsub}),[store,atom,delay]),(0,react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)(value),isPromiseLike(value)){const promise=createContinuablePromise(value);return use(promise)}return value}function useSetAtom(atom,options){const store=useStore(options);return(0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(((...args)=>{if(!("write"in atom))throw new Error("not writable atom");return store.set(atom,...args)}),[store,atom])}function useAtom(atom,options){return[useAtomValue(atom,options),useSetAtom(atom,options)]}},"../../../node_modules/.pnpm/jotai@2.11.3_@types+react@18.3.20_react@18.2.0/node_modules/jotai/esm/vanilla.mjs":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.d(__webpack_exports__,{K0:function(){return getDefaultStore},Zf:function(){return atom}});let keyCount=0;function atom(read,write){const key="atom"+ ++keyCount,config={toString(){return this.debugLabel?key+":"+this.debugLabel:key}};return"function"==typeof read?config.read=read:(config.init=read,config.read=defaultRead,config.write=defaultWrite),write&&(config.write=write),config}function defaultRead(get){return get(this)}function defaultWrite(get,set,arg){return set(this,"function"==typeof arg?arg(get(this)):arg)}const isSelfAtom=(atom,a)=>atom.unstable_is?atom.unstable_is(a):a===atom,hasInitialValue=atom=>"init"in atom,isActuallyWritableAtom=atom=>!!atom.write,cancelablePromiseMap=new WeakMap,isPendingPromise=value=>{var _a;return isPromiseLike(value)&&!(null==(_a=cancelablePromiseMap.get(value))?void 0:_a[1])},isPromiseLike=p=>"function"==typeof(null==p?void 0:p.then),isAtomStateInitialized=atomState=>"v"in atomState||"e"in atomState,returnAtomValue=atomState=>{if("e"in atomState)throw atomState.e;if(!("v"in atomState))throw new Error("[Bug] atom state is not initialized");return atomState.v},addPendingPromiseToDependency=(atom,promise,dependencyAtomState)=>{dependencyAtomState.p.has(atom)||(dependencyAtomState.p.add(atom),promise.then((()=>{dependencyAtomState.p.delete(atom)}),(()=>{dependencyAtomState.p.delete(atom)})))},INTERNAL_flushStoreHook=Symbol.for("JOTAI.EXPERIMENTAL.FLUSHSTOREHOOK"),buildStore=(...storeArgs)=>{const[getAtomState,setAtomState,atomRead,atomWrite,atomOnInit,atomOnMount]=storeArgs,ensureAtomState=atom=>{if(!atom)throw new Error("Atom is undefined or null");let atomState=getAtomState(atom);return atomState||(atomState={d:new Map,p:new Set,n:0},setAtomState(atom,atomState),null==atomOnInit||atomOnInit(atom,store)),atomState},invalidatedAtoms=new WeakMap,changedAtoms=new Map,unmountCallbacks=new Set,mountCallbacks=new Set,flushCallbacks=()=>{var _a;const errors=[],call=fn=>{try{fn()}catch(e){errors.push(e)}};do{null==(_a=store[INTERNAL_flushStoreHook])||_a.call(store);const callbacks=new Set,add=callbacks.add.bind(callbacks);changedAtoms.forEach((atomState=>{var _a2;return null==(_a2=atomState.m)?void 0:_a2.l.forEach(add)})),changedAtoms.clear(),unmountCallbacks.forEach(add),unmountCallbacks.clear(),mountCallbacks.forEach(add),mountCallbacks.clear(),callbacks.forEach(call),changedAtoms.size&&recomputeInvalidatedAtoms()}while(changedAtoms.size||unmountCallbacks.size||mountCallbacks.size);if(errors.length)throw errors[0]},setAtomStateValueOrPromise=(atom,atomState,valueOrPromise)=>{const hasPrevValue="v"in atomState,prevValue=atomState.v,pendingPromise=isPendingPromise(atomState.v)?atomState.v:null;if(isPromiseLike(valueOrPromise)){(promise=>{if(cancelablePromiseMap.has(promise))return;const promiseState=[new Set,!1];cancelablePromiseMap.set(promise,promiseState);const settle=()=>{promiseState[1]=!0};promise.then(settle,settle),promise.onCancel=fn=>{promiseState[0].add(fn)}})(valueOrPromise);for(const a of atomState.d.keys())addPendingPromiseToDependency(atom,valueOrPromise,ensureAtomState(a));atomState.v=valueOrPromise}else atomState.v=valueOrPromise;delete atomState.e,hasPrevValue&&Object.is(prevValue,atomState.v)||(++atomState.n,pendingPromise&&((promise,nextValue)=>{const promiseState=cancelablePromiseMap.get(promise);if(!promiseState)throw new Error("[Bug] cancelable promise not found");promiseState[1]=!0,promiseState[0].forEach((fn=>fn(nextValue)))})(pendingPromise,valueOrPromise))},readAtomState=atom=>{var _a,_b;const atomState=ensureAtomState(atom);if(isAtomStateInitialized(atomState)){if(atomState.m&&invalidatedAtoms.get(atom)!==atomState.n)return atomState;if(Array.from(atomState.d).every((([a,n])=>readAtomState(a).n===n)))return atomState}atomState.d.clear();let isSync=!0;const mountDependenciesIfAsync=()=>{atomState.m&&(mountDependencies(atom,atomState),recomputeInvalidatedAtoms(),flushCallbacks())},getter=a=>{if(isSelfAtom(atom,a)){const aState2=ensureAtomState(a);if(!isAtomStateInitialized(aState2)){if(!hasInitialValue(a))throw new Error("no atom init");setAtomStateValueOrPromise(a,aState2,a.init)}return returnAtomValue(aState2)}const aState=readAtomState(a);try{return returnAtomValue(aState)}finally{((atom,atomState,a,aState)=>{var _a;if(a===atom)throw new Error("[Bug] atom cannot depend on itself");atomState.d.set(a,aState.n),isPendingPromise(atomState.v)&&addPendingPromiseToDependency(atom,atomState.v,aState),null==(_a=aState.m)||_a.t.add(atom)})(atom,atomState,a,aState),isSync||mountDependenciesIfAsync()}};let controller,setSelf;const options={get signal(){return controller||(controller=new AbortController),controller.signal},get setSelf(){return isActuallyWritableAtom(atom)||console.warn("setSelf function cannot be used with read-only atom"),!setSelf&&isActuallyWritableAtom(atom)&&(setSelf=(...args)=>{if(isSync&&console.warn("setSelf function cannot be called in sync"),!isSync)return writeAtom(atom,...args)}),setSelf}},prevEpochNumber=atomState.n;try{const valueOrPromise=atomRead(atom,getter,options);return setAtomStateValueOrPromise(atom,atomState,valueOrPromise),isPromiseLike(valueOrPromise)&&(null==(_a=valueOrPromise.onCancel)||_a.call(valueOrPromise,(()=>null==controller?void 0:controller.abort())),valueOrPromise.then(mountDependenciesIfAsync,mountDependenciesIfAsync)),atomState}catch(error){return delete atomState.v,atomState.e=error,++atomState.n,atomState}finally{isSync=!1,prevEpochNumber!==atomState.n&&invalidatedAtoms.get(atom)===prevEpochNumber&&(invalidatedAtoms.set(atom,atomState.n),changedAtoms.set(atom,atomState),null==(_b=atomState.u)||_b.call(atomState))}},getMountedOrPendingDependents=atomState=>{var _a;const dependents=new Map;for(const a of(null==(_a=atomState.m)?void 0:_a.t)||[]){const aState=ensureAtomState(a);aState.m&&dependents.set(a,aState)}for(const atomWithPendingPromise of atomState.p)dependents.set(atomWithPendingPromise,ensureAtomState(atomWithPendingPromise));return dependents},invalidateDependents=atomState=>{const stack=[atomState];for(;stack.length;){const aState=stack.pop();for(const[d,s]of getMountedOrPendingDependents(aState))invalidatedAtoms.set(d,s.n),stack.push(s)}},recomputeInvalidatedAtoms=()=>{var _a;const topSortedReversed=[],visiting=new WeakSet,visited=new WeakSet,stack=Array.from(changedAtoms);for(;stack.length;){const[a,aState]=stack[stack.length-1];if(visited.has(a))stack.pop();else if(visiting.has(a))invalidatedAtoms.get(a)===aState.n?topSortedReversed.push([a,aState,aState.n]):(invalidatedAtoms.delete(a),changedAtoms.set(a,aState)),visited.add(a),stack.pop();else{visiting.add(a);for(const[d,s]of getMountedOrPendingDependents(aState))visiting.has(d)||stack.push([d,s])}}for(let i=topSortedReversed.length-1;i>=0;--i){const[a,aState,prevEpochNumber]=topSortedReversed[i];let hasChangedDeps=!1;for(const dep of aState.d.keys())if(dep!==a&&changedAtoms.has(dep)){hasChangedDeps=!0;break}hasChangedDeps&&(readAtomState(a),mountDependencies(a,aState),prevEpochNumber!==aState.n&&(changedAtoms.set(a,aState),null==(_a=aState.u)||_a.call(aState))),invalidatedAtoms.delete(a)}},writeAtomState=(atom,...args)=>{let isSync=!0;const getter=a=>returnAtomValue(readAtomState(a)),setter=(a,...args2)=>{var _a;const aState=ensureAtomState(a);try{if(isSelfAtom(atom,a)){if(!hasInitialValue(a))throw new Error("atom not writable");const prevEpochNumber=aState.n,v=args2[0];return setAtomStateValueOrPromise(a,aState,v),mountDependencies(a,aState),void(prevEpochNumber!==aState.n&&(changedAtoms.set(a,aState),null==(_a=aState.u)||_a.call(aState),invalidateDependents(aState)))}return writeAtomState(a,...args2)}finally{isSync||(recomputeInvalidatedAtoms(),flushCallbacks())}};try{return atomWrite(atom,getter,setter,...args)}finally{isSync=!1}},writeAtom=(atom,...args)=>{try{return writeAtomState(atom,...args)}finally{recomputeInvalidatedAtoms(),flushCallbacks()}},mountDependencies=(atom,atomState)=>{var _a;if(atomState.m&&!isPendingPromise(atomState.v)){for(const[a,n]of atomState.d)if(!atomState.m.d.has(a)){const aState=ensureAtomState(a);mountAtom(a,aState).t.add(atom),atomState.m.d.add(a),n!==aState.n&&(changedAtoms.set(a,aState),null==(_a=aState.u)||_a.call(aState),invalidateDependents(aState))}for(const a of atomState.m.d||[])if(!atomState.d.has(a)){atomState.m.d.delete(a);const aMounted=unmountAtom(a,ensureAtomState(a));null==aMounted||aMounted.t.delete(atom)}}},mountAtom=(atom,atomState)=>{var _a;if(!atomState.m){readAtomState(atom);for(const a of atomState.d.keys()){mountAtom(a,ensureAtomState(a)).t.add(atom)}if(atomState.m={l:new Set,d:new Set(atomState.d.keys()),t:new Set},null==(_a=atomState.h)||_a.call(atomState),isActuallyWritableAtom(atom)){const mounted=atomState.m,processOnMount=()=>{let isSync=!0;const setAtom=(...args)=>{try{return writeAtomState(atom,...args)}finally{isSync||(recomputeInvalidatedAtoms(),flushCallbacks())}};try{const onUnmount=atomOnMount(atom,setAtom);onUnmount&&(mounted.u=()=>{isSync=!0;try{onUnmount()}finally{isSync=!1}})}finally{isSync=!1}};mountCallbacks.add(processOnMount)}}return atomState.m},unmountAtom=(atom,atomState)=>{var _a;if(!atomState.m||atomState.m.l.size||Array.from(atomState.m.t).some((a=>{var _a2;return null==(_a2=ensureAtomState(a).m)?void 0:_a2.d.has(atom)})))return atomState.m;{const onUnmount=atomState.m.u;onUnmount&&unmountCallbacks.add(onUnmount),delete atomState.m,null==(_a=atomState.h)||_a.call(atomState);for(const a of atomState.d.keys()){const aMounted=unmountAtom(a,ensureAtomState(a));null==aMounted||aMounted.t.delete(atom)}}},store={get:atom=>returnAtomValue(readAtomState(atom)),set:writeAtom,sub:(atom,listener)=>{const atomState=ensureAtomState(atom),listeners=mountAtom(atom,atomState).l;return listeners.add(listener),flushCallbacks(),()=>{listeners.delete(listener),unmountAtom(atom,atomState),flushCallbacks()}},unstable_derive:fn=>buildStore(...fn(...storeArgs))};return store},createStore=()=>{const atomStateMap=new WeakMap,store=buildStore((atom=>atomStateMap.get(atom)),((atom,atomState)=>atomStateMap.set(atom,atomState).get(atom)),((atom,...params)=>atom.read(...params)),((atom,...params)=>atom.write(...params)),((atom,...params)=>{var _a;return null==(_a=atom.unstable_onInit)?void 0:_a.call(atom,...params)}),((atom,...params)=>{var _a;return null==(_a=atom.onMount)?void 0:_a.call(atom,...params)}));return(store=>{const debugMountedAtoms=new Set;let savedGetAtomState,inRestoreAtom=0;const derivedStore=store.unstable_derive(((...storeArgs)=>{const[getAtomState,setAtomState,,atomWrite]=storeArgs;return savedGetAtomState=getAtomState,storeArgs[1]=function devSetAtomState(atom,atomState){setAtomState(atom,atomState);const originalMounted=atomState.h;atomState.h=()=>{null==originalMounted||originalMounted(),atomState.m?debugMountedAtoms.add(atom):debugMountedAtoms.delete(atom)}},storeArgs[3]=function devAtomWrite(atom,getter,setter,...args){return inRestoreAtom?setter(atom,...args):atomWrite(atom,getter,setter,...args)},storeArgs})),savedStoreSet=derivedStore.set,devStore={dev4_get_internal_weak_map:()=>({get:atom=>{const atomState=savedGetAtomState(atom);if(atomState&&0!==atomState.n)return atomState}}),dev4_get_mounted_atoms:()=>debugMountedAtoms,dev4_restore_atoms:values=>{const restoreAtom={read:()=>null,write:(_get,set)=>{++inRestoreAtom;try{for(const[atom,value]of values)hasInitialValue(atom)&&set(atom,value)}finally{--inRestoreAtom}}};savedStoreSet(restoreAtom)}};return Object.assign(derivedStore,devStore)})(store)};let defaultStore;const getDefaultStore=()=>(defaultStore||(defaultStore=createStore(),globalThis.__JOTAI_DEFAULT_STORE__||(globalThis.__JOTAI_DEFAULT_STORE__=defaultStore),globalThis.__JOTAI_DEFAULT_STORE__!==defaultStore&&console.warn("Detected multiple Jotai instances. It may cause unexpected behavior with the default store. https://github.com/pmndrs/jotai/discussions/2044")),defaultStore)},"../../../node_modules/.pnpm/jotai@2.11.3_@types+react@18.3.20_react@18.2.0/node_modules/jotai/esm/vanilla/utils.mjs":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.d(__webpack_exports__,{KU:function(){return atomFamily}});Symbol("RESET");function atomFamily(initializeAtom,areEqual){let shouldRemove=null;const atoms=new Map,listeners=new Set,createAtom=param=>{let item;if(void 0===areEqual)item=atoms.get(param);else for(const[key,value]of atoms)if(areEqual(key,param)){item=value;break}if(void 0!==item){if(!(null==shouldRemove?void 0:shouldRemove(item[1],param)))return item[0];createAtom.remove(param)}const newAtom=initializeAtom(param);return atoms.set(param,[newAtom,Date.now()]),notifyListeners("CREATE",param,newAtom),newAtom};function notifyListeners(type,param,atom){for(const listener of listeners)listener({type:type,param:param,atom:atom})}return createAtom.unstable_listen=callback=>(listeners.add(callback),()=>{listeners.delete(callback)}),createAtom.getParams=()=>atoms.keys(),createAtom.remove=param=>{if(void 0===areEqual){if(!atoms.has(param))return;const[atom]=atoms.get(param);atoms.delete(param),notifyListeners("REMOVE",param,atom)}else for(const[key,[atom]]of atoms)if(areEqual(key,param)){atoms.delete(key),notifyListeners("REMOVE",key,atom);break}},createAtom.setShouldRemove=fn=>{if(shouldRemove=fn,shouldRemove)for(const[key,[atom,createdAt]]of atoms)shouldRemove(createdAt,key)&&(atoms.delete(key),notifyListeners("REMOVE",key,atom))},createAtom}const isPromiseLike=x=>"function"==typeof(null==x?void 0:x.then);(function createJSONStorage(getStringStorage=()=>{try{return window.localStorage}catch(e){return void("undefined"!=typeof window&&console.warn(e))}},options){var _a;let lastStr,lastValue;const storage={getItem:(key,initialValue)=>{var _a2,_b;const parse=str2=>{if(lastStr!==(str2=str2||"")){try{lastValue=JSON.parse(str2,null==options?void 0:options.reviver)}catch(e){return initialValue}lastStr=str2}return lastValue},str=null!=(_b=null==(_a2=getStringStorage())?void 0:_a2.getItem(key))?_b:null;return isPromiseLike(str)?str.then(parse):parse(str)},setItem:(key,newValue)=>{var _a2;return null==(_a2=getStringStorage())?void 0:_a2.setItem(key,JSON.stringify(newValue,null==options?void 0:options.replacer))},removeItem:key=>{var _a2;return null==(_a2=getStringStorage())?void 0:_a2.removeItem(key)}};let subscriber;try{subscriber=null==(_a=getStringStorage())?void 0:_a.subscribe}catch(e){}var subscriber2;return!subscriber&&"undefined"!=typeof window&&"function"==typeof window.addEventListener&&window.Storage&&(subscriber=(key,callback)=>{if(!(getStringStorage()instanceof window.Storage))return()=>{};const storageEventCallback=e=>{e.storageArea===getStringStorage()&&e.key===key&&callback(e.newValue)};return window.addEventListener("storage",storageEventCallback),()=>{window.removeEventListener("storage",storageEventCallback)}}),subscriber&&(storage.subscribe=(subscriber2=subscriber,(key,callback,initialValue)=>subscriber2(key,(v=>{let newValue;try{newValue=JSON.parse(v||"")}catch(e){newValue=initialValue}callback(newValue)})))),storage})()},"../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseExtremum.js":function(module,__unused_webpack_exports,__webpack_require__){var isSymbol=__webpack_require__("../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isSymbol.js");module.exports=function baseExtremum(array,iteratee,comparator){for(var index=-1,length=array.length;++index<length;){var value=array[index],current=iteratee(value);if(null!=current&&(void 0===computed?current==current&&!isSymbol(current):comparator(current,computed)))var computed=current,result=value}return result}},"../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseLt.js":function(module){module.exports=function baseLt(value,other){return value<other}},"../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseXor.js":function(module,__unused_webpack_exports,__webpack_require__){var baseDifference=__webpack_require__("../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseDifference.js"),baseFlatten=__webpack_require__("../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseFlatten.js"),baseUniq=__webpack_require__("../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseUniq.js");module.exports=function baseXor(arrays,iteratee,comparator){var length=arrays.length;if(length<2)return length?baseUniq(arrays[0]):[];for(var index=-1,result=Array(length);++index<length;)for(var array=arrays[index],othIndex=-1;++othIndex<length;)othIndex!=index&&(result[index]=baseDifference(result[index]||array,arrays[othIndex],iteratee,comparator));return baseUniq(baseFlatten(result,1),iteratee,comparator)}},"../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/mapValues.js":function(module,__unused_webpack_exports,__webpack_require__){var baseAssignValue=__webpack_require__("../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseAssignValue.js"),baseForOwn=__webpack_require__("../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseForOwn.js"),baseIteratee=__webpack_require__("../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIteratee.js");module.exports=function mapValues(object,iteratee){var result={};return iteratee=baseIteratee(iteratee,3),baseForOwn(object,(function(value,key,object){baseAssignValue(result,key,iteratee(value,key,object))})),result}},"../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/min.js":function(module,__unused_webpack_exports,__webpack_require__){var baseExtremum=__webpack_require__("../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseExtremum.js"),baseLt=__webpack_require__("../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseLt.js"),identity=__webpack_require__("../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/identity.js");module.exports=function min(array){return array&&array.length?baseExtremum(array,identity,baseLt):void 0}},"../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/xor.js":function(module,__unused_webpack_exports,__webpack_require__){var arrayFilter=__webpack_require__("../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayFilter.js"),baseRest=__webpack_require__("../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseRest.js"),baseXor=__webpack_require__("../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseXor.js"),isArrayLikeObject=__webpack_require__("../../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isArrayLikeObject.js"),xor=baseRest((function(arrays){return baseXor(arrayFilter(arrays,isArrayLikeObject))}));module.exports=xor}}]);